import java.util.*;

public class PrimeraSolucionWarnsdorff {

    public static final int N = 6;
    public static int[][] tablero = new int[N][N];
    private static final int[] dx = {-2, -1, 1, 2, 2, 1, -1, -2};
    private static final int[] dy = {1, 2, 2, 1, -1, -2, -2, -1};

    public static void iniciarSolucion() {
        for (int i = 0; i < N; i++) {
            Arrays.fill(tablero[i], 0);
        }

        Random rand = new Random();
        int x = rand.nextInt(N);
        int y = rand.nextInt(N);
        tablero[x][y] = 1;

        buscarPrimeraSolucion(x, y, 2);
    }

    private static boolean buscarPrimeraSolucion(int x, int y, int paso) {
        if (paso == N * N + 1) return true;

        int minGrado = 9;
        int mejorX = -1, mejorY = -1;

        // Buscar el movimiento con menor grado de libertad (menos opciones futuras)
        for (int i = 0; i < 8; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (esValido(nx, ny)) {
                int grado = contarMovimientosDisponibles(nx, ny);
                if (grado < minGrado) {
                    minGrado = grado;
                    mejorX = nx;
                    mejorY = ny;
                }
            }
        }

        if (mejorX == -1) {
            // No hay movimientos válidos, retrocede
            return false;
        }

        // Intentar primero el mejor movimiento según Warnsdorff
        tablero[mejorX][mejorY] = paso;
        if (buscarPrimeraSolucion(mejorX, mejorY, paso + 1)) return true;
        tablero[mejorX][mejorY] = 0; // Retroceder

        // Si falla, intenta los demás movimientos en cualquier orden
        for (int i = 0; i < 8; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (esValido(nx, ny) && !(nx == mejorX && ny == mejorY)) {
                tablero[nx][ny] = paso;
                if (buscarPrimeraSolucion(nx, ny, paso + 1)) return true;
                tablero[nx][ny] = 0; // Retroceder
            }
        }
        return false;
    }

    private static int contarMovimientosDisponibles(int x, int y) {
        int cuenta = 0;
        for (int i = 0; i < 8; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (esValido(nx, ny)) cuenta++;
        }
        return cuenta;
    }

    private static boolean esValido(int x, int y) {
        return x >= 0 && y >= 0 && x < N && y < N && tablero[x][y] == 0;
    }
}
